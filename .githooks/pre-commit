#!/bin/bash
#
# pre-commit hook for agent-toolkit
# Prevents secrets, sensitive paths, and internal references from being committed.
#
# Install: git config core.hooksPath .githooks
#

set -e

RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
NC='\033[0m'

FAILED=0
WARNINGS=0

# Get list of staged files (only added/modified, skip deleted)
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM 2>/dev/null)

if [[ -z "$STAGED_FILES" ]]; then
    exit 0
fi

echo "ðŸ”’ Running security checks..."
echo ""

# --- Check 1: Forbidden patterns (secrets & keys) ---

check_secrets() {
    local file="$1"

    # Skip binary files
    if file "$file" | grep -q "binary"; then
        return 0
    fi

    # Skip security infrastructure files (they contain patterns, not secrets)
    case "$file" in
        .githooks/*|.gitleaks.toml|.github/workflows/security.yml)
            return 0
            ;;
    esac

    local patterns=(
        # API keys and tokens
        'AKIA[0-9A-Z]{16}'                          # AWS Access Key
        'sk-[a-zA-Z0-9]{20,}'                       # OpenAI/Stripe secret key
        'sk-ant-[a-zA-Z0-9-]{20,}'                  # Anthropic API key
        'ghp_[a-zA-Z0-9]{36}'                       # GitHub personal access token
        'gho_[a-zA-Z0-9]{36}'                       # GitHub OAuth token
        'github_pat_[a-zA-Z0-9_]{22,}'              # GitHub fine-grained PAT
        'xox[bpors]-[a-zA-Z0-9-]+'                  # Slack tokens
        'hooks\.slack\.com/services/T[A-Z0-9]+/'    # Slack webhook
        'sq0[a-z]{3}-[a-zA-Z0-9_-]{22,}'            # Square tokens
        'AIza[0-9A-Za-z_-]{35}'                     # Google API key
        'ya29\.[0-9A-Za-z_-]+'                      # Google OAuth token

        # Private keys and certificates
        'BEGIN (RSA |EC |DSA |OPENSSH )?PRIVATE KEY'
        'BEGIN CERTIFICATE'

        # Connection strings and passwords
        'password\s*[:=]\s*["\x27][^"\x27]{8,}'     # password = "..."
        'secret\s*[:=]\s*["\x27][^"\x27]{8,}'       # secret = "..."
        'api_key\s*[:=]\s*["\x27][^"\x27]{8,}'      # api_key = "..."
        'token\s*[:=]\s*["\x27][^"\x27]{8,}'        # token = "..."
        'mysql://[^:]+:[^@]+@'                       # MySQL connection string
        'postgres://[^:]+:[^@]+@'                    # PostgreSQL connection string
        'mongodb(\+srv)?://[^:]+:[^@]+@'             # MongoDB connection string
    )

    for pattern in "${patterns[@]}"; do
        local matches
        matches=$(grep -nEi "$pattern" "$file" 2>/dev/null || true)
        if [[ -n "$matches" ]]; then
            echo -e "${RED}BLOCKED${NC} Potential secret in ${file}:"
            echo "$matches" | head -3
            echo ""
            FAILED=1
            return 1
        fi
    done
}

# --- Check 2: Internal/private references ---

check_internal_refs() {
    local file="$1"

    if file "$file" | grep -q "binary"; then
        return 0
    fi

    # Skip security infrastructure files (they reference patterns by definition)
    case "$file" in
        .githooks/*|.gitleaks.toml|.github/workflows/security.yml)
            return 0
            ;;
    esac

    # Patterns that should NEVER appear in the public repo
    local forbidden_patterns=(
        '/Users/[a-zA-Z]'          # Any absolute macOS user path
        '/home/[a-zA-Z]'           # Any absolute Linux user path
        '[Mm]inerva'                # Internal project name (case-insensitive)
    )

    # Allowed exceptions
    local exceptions=(
        'my-project'                # Sanitized placeholder is OK
    )

    for pattern in "${forbidden_patterns[@]}"; do
        local matches
        matches=$(grep -n "$pattern" "$file" 2>/dev/null || true)

        if [[ -n "$matches" ]]; then
            # Check if all matches are in allowed exceptions
            local real_matches=""
            while IFS= read -r line; do
                local is_exception=false
                for exc in "${exceptions[@]}"; do
                    if echo "$line" | grep -q "$exc"; then
                        is_exception=true
                        break
                    fi
                done
                if [[ "$is_exception" == "false" ]]; then
                    real_matches="${real_matches}${line}\n"
                fi
            done <<< "$matches"

            if [[ -n "$real_matches" ]]; then
                echo -e "${RED}BLOCKED${NC} Internal reference '${pattern}' in ${file}:"
                echo -e "$real_matches" | head -3
                echo ""
                FAILED=1
            fi
        fi
    done
}

# --- Check 3: Dangerous file types ---

check_dangerous_files() {
    local file="$1"
    local basename
    basename=$(basename "$file")
    local ext="${basename##*.}"

    # Files that should never be committed
    local dangerous_names=(
        '.env'
        '.env.local'
        '.env.production'
        'credentials.json'
        'credentials.yaml'
        'credentials.yml'
        'service-account.json'
        'id_rsa'
        'id_ed25519'
        'id_ecdsa'
        '.npmrc'
        '.pypirc'
        '.netrc'
    )

    local dangerous_extensions=(
        'pem'
        'key'
        'p12'
        'pfx'
        'jks'
        'keystore'
    )

    for name in "${dangerous_names[@]}"; do
        if [[ "$basename" == "$name" ]]; then
            echo -e "${RED}BLOCKED${NC} Dangerous file: ${file}"
            echo "  This file type commonly contains secrets."
            echo ""
            FAILED=1
            return 1
        fi
    done

    for dext in "${dangerous_extensions[@]}"; do
        if [[ "$ext" == "$dext" ]]; then
            echo -e "${RED}BLOCKED${NC} Dangerous file extension: ${file} (*.${dext})"
            echo "  This file type commonly contains private keys or certificates."
            echo ""
            FAILED=1
            return 1
        fi
    done
}

# --- Run all checks ---

for file in $STAGED_FILES; do
    # Skip if file doesn't exist (deleted)
    [[ ! -f "$file" ]] && continue

    check_dangerous_files "$file"
    check_secrets "$file"
    check_internal_refs "$file"
done

# --- Summary ---

echo ""
if [[ $FAILED -eq 1 ]]; then
    echo -e "${RED}âŒ Pre-commit checks FAILED${NC}"
    echo ""
    echo "Fix the issues above before committing."
    echo "If this is a false positive, use: git commit --no-verify"
    echo "(But think twice â€” this repo is PUBLIC)"
    exit 1
else
    echo -e "${GREEN}âœ… All security checks passed${NC}"
fi
